<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>EQATEC .Net Tracer - User's Guide</title>
        <link rel="stylesheet" type="text/css" href="style.css" />
    </head>
	<body>

	<h1>The EQATEC .Net Tracer</h1>
	
	<p>This guide contains:</p>
	<pre>
        <a href="#guide">Quick guide to tracing</a>
	        <a href="#step1">Step 1: Drop your assemblies in the tracer</a>
	        <a href="#step2">Step 2: Instrument assemblies</a>
	        <a href="#step3">Step 3: Run and connect</a>
	        <a href="#step4">Step 4: View and control output</a>
	        <a href="#appendixA">Appendix A: Debug boot crashes</a>
	        <a href="#demoapplication">Demo Application</a>
        <a href="#limitations">Known limitations</a>
        <a href="#contact">Contact information</a>
	</pre>

    <a id="guide" />
	<h1>Quick guide to tracing</h1>
	<p>The tracer works by injecting tracing code in every function and property in your assemblies. 
	Every time a function is called this piece of code checks to see if the trace is enabled. If so a trace is generated and send to the viewer. 
	The trace contains information on the functions called and a result of ToString() on every parameter</p>
	<img class="center" src="images/4Steps.gif" alt="How to trace your assemblies"/>
	<p>You will use the tracer in four steps:</p>
	<ol>
	<li><strong>Drop</strong> your assemblies somewhere in the window</li>
	<li><strong>Start</strong> instrumentation to inject tracing code into the assemblies</li>
	<li><strong>Run</strong> the modified application on your PC or device</li>
	<li><strong>View and control</strong> your trace from the viewer section</li>
	</ol>
	<p>That's it. That is all you need to do. You can try it out now on the
	demo-app, "Sudoku", or on any full .NET application you have installed.
	</p>
	<p>The next sections will describe these four steps.</p>
	
    <a id="step1" />
	<h2>Step 1: Drop your assemblies somewhere in the window</h2>
	<p>Select your application folder and drop it in the window. The .Net assemblies present in the folder structure will
	be added to the assembly list. If there is any signed assemblies you will prompted to deal with them either by providing a key for resigning or
	simply by skipping them all together</p>
	<p>You deselect any assemblies you do not want to instrument. It will then only be copied to the output folder and used as is</p>
	
    <a id="step2" />
	<h2>Step 2: Start instrumentation to inject tracing code into the assemblies</h2>
	<p>The <strong>Instrumentator</strong> tab is explained below:</p>
	  <img class="center" src="images/InstrumentorGuide.gif" alt="Trace your application"/>
  <p>A traced assembly is typically 30% larger than the original and runs slightly slower. The more trace enabled the larger the performance penalty will
  be. The performance penalty will vary greatly depending
  on your application structure.
	Normally you will just trace all
	of your assembly-files, but sometimes you would like to be more particular - for instance, if
	</p>
	<ul>
	<li>your device has no room for that extra code</li>
	<li>an assembly-file is highly time-critical and cannot stand the extra runtime-overhead</li>
	</ul>
	<p></p>
		
  <a id="step3" />
	<h2>Step 3: Run the modified application on your PC or device</h2>
	<p>When the instrumentation has finished you simply click on the flash icon to launch your application. If you have several executables you will be prompted 
	to choose which one you want to execute. When the application is launched the view will change to the <strong>Viewer</strong> tab.</p>
	<p>When running on a device the launch of the application will have to be done by hand. Go to the <strong>"YourApp (Traced)"</strong> folder (you can find the exact path 
	in the instrumentation messages). Copy the contents to the device and launch from the device. 
	</p>

    <a id="step4" />
    <h2>Step 4: View and control your trace from the viewer section</h2>
    <p>Now we're ready to see some output from the application. Below is the <strong>Viewer</strong> tab functionality shown</p>
	 	<img class="center" src="images/ViewerGuide.gif" alt="Trace your application"/>
  <p>On the left hand side is the <strong>Control Tree</strong>. This is where you control which members you want to see output from. 
  On the right hand side is the <strong>Trace Viewer</strong>. This is where the the trace is shown when it has been generated by the application</p>
	<h3>Control tree</h3>
	<ul>
	<li>The control tree toolbar holds undo and redo buttons for used for control tree actions. It holds a target IP box defaulting to LocalHost. If you need 
	to trace an application running on a device type the device IP and connect. The play button attempts to connect to the target</li>
	<li>The control tree holds all the assemblies in your application. You can expland the tree down to the individual methods on every type. When you check 
	an item in the tree it enables all sub nodes in the tree. Be carefull when enabling on a assembly level this can generate a lot of output. If your selection
	seems to generate to much output simply deselect or undo your action.
	</li>
	<li>When your at a method level there is a context menu giving you the following options
	<p>
	<img class="center" src="images/TreeContext.gif" alt="Tree context menu"/>
	</p>
	This enables you to not only enable this particular method, but also to enable its callers five levels up. This is usefull when you are unaware of how exactly 
	a particular method is called.
	</li>
	</ul>
	
	<h3>Trace viewer</h3>
	<ul>
	<li>The toolbar in the <strong>Trace viewer</strong> section gives you a selection of tools to control the flow information. 
	These are for the most part self explanatory, however some of them needs some explanation. The pause button will pause the 
	traceviewer and no new lines will enter the viewer. This means that trace arriving at the viewer will be dumped and lost. 
	The save button will save all present trace to a text file. The close parameter window button will close all open parameter windows. 
	Parameter windows can be opened by double clicking 	on a trace line</li>
	<li>The trace output itself is generated with like so <strong><em>timestamp (threadid) methodname (parametervalue1, ...)</em></strong>. 
	Left clicking on a line will bring up additional information in the parameter window below. Double clicking on a line will 
	open a seperate parameter window. Right clicking on a line will bring up the same context menu as in the control tree. 
	<p>
	<img class="center" src="images/TraceContext.gif" alt="Trace context menu"/>
	</p>
	This will enable you to control the trace directly from the trace window itself. This is usefull for disabling trace that is of no interest in your present 
	debugging scenario</li>	
	<li>Below the trace output is the buffer management section. 
	<p>
	<img class="center" src="images/BufferManagement.gif" alt="Buffer management"/>
	</p>
	The bar shows you how much trace is currently accumulated 
	in the target application. The time shown is the time difference between the oldest and the newest trace in the buffer. 
	The bar can jump in size in scenarios where there are bursts of trace at longer intervals. 
	If the buffer still holds old trace being send, new trace added will make the bar grow suddenly.
	</li>
	<li>The <strong>Max allowed delay</strong> slider will set the maximum allowed delay in the trace buffer. If the delay is exceeded 
	the buffer will be flushed. Flushing events will be signaled in the trace window with a line describing how many lines where removed. 
	If you generate a lot of trace and you are experiencing flushing events increase the delay. If you don't want old trace to appear 
	in the trace window or have limited space for buffering in your target application decrease the delay
	</li>
	<li>If you enable a lot of trace you can encounter scenarios where the tracer is unable to cope with the amounts of data. 
	The trace line queue in the target application is limited to 30000 lines. If this amount is exceeded it will start dumping lines. 
	Every time dumping occurs this will be signaled in the trace output.
	</li>
	</ul>
    <a id="appendixA" />
    <h2>Appendix A: Debug boot crashes</h2>
    <p>Debugging application boot crashes is a normal debugging scenario. As you read previously the tracer have to connected
    to show trace. This is not possible when your application crashes on boot. This shows how you can still find the reason for the crash
    using the <strong>EQATEC Tracer</strong></p>

    <ul>
      <li>
      Instrument your application as usual but do not start it from the instrumentation view.
      </li>
      <li>
      Switch to the viewer tab manually and press the connect button. The following window will appear.
      <p>
        <img class="center" src="images/WaitWindow.gif" alt="Waiting for connection"/>
      </p>
      This means that the viewer is waiting for the application to start and when it does it will connect immediatly. 
      </li>
      <li>Start your application. Your instrumented application will then detect that the viewer have connected and will 
      block in its first called method (usually Main()) until it has exchanged assembly info. It will then continue to boot and crash</li>
      <li>The viewer is now in offline mode. This is signaled by the play button in the control tree side is enabled. The tree is however
      still active. You now enable whatever you need to debug the crash and press play again. The viewer will again wait for the target 
      to start
      </li>
      <li>
      Start the target application again. It will again wait in the first called method to exchange assembly information, but this time it will 
      also exchange info on the function you enabled in offline mode. When it has finished the target application will continue to boot but this 
      time it will trace whatever you enabled hopefully giving you enough information to solve the problem
      </li>
    </ul>
  
    <a id="demoapplication" />
    <h1>Demo application</h1>
    <p>The demo application is to be used as a easy introduction to tracing. Can you cheat with the info from the tracer ;) Further detail about the demo application can be viewed here</p>
    <a href="http://www.codeplex.com/Sudoku">http://www.codeplex.com/Sudoku</a>
    
    <a id="limitations" />
    <h1>Known limitations</h1>
    <p>This is a list of known limitations.</p>
    <ul>
    <li><strong>Only defined methods</strong> are currently traced, not referenced ones.
    So all the methods that your application itself defines will be traced, but not System.* etc.</li>
    <li><strong>Only outputs ToString()</strong> If there are no ToString() method the type will be the result of the output. You can enhance 
    the output by overriding ToString() in your types.
    </li>
    </ul>

    <a id="contact" />
    <h1>Contact</h1>
    <p>The tracer is a work in progress. Your input is most welcome: if you have
    any problems or suggestions then please let us know.</p>
    <p>
    Visit our forum at <a href="http://www.eqatec.com/forum">http://www.eqatec.com/forum</a><br />
    Send us an email at <a href="mailto://tools@eqatec.com">tools@eqatec.com</a>
    </p>
    <p>If you experience a bug, such as your traced program not working or throwing an
    exception, then maybe we can help:</p>
    <ol>
    <li>First of all, check if there's maybe a newer tracer version available</li>
    <li>If not then please report the problem in our forum, or by mail</li>
    <li>Next, see if you can reproduce the problem on a smaller scale and send us a source example</li>
    <li>Or, submit as much info about the problem as possible; call-stack, types involved etc</li>
    <li>Or, submit the offending assembly-files to us</li>
    <li>Or, submit your entire offending source code project to us</li>
    </ol>
    <p>If you'd like professional assistance in performance-tuning or improving your .NET CF application
    then don't hesitate to contact us, either. Because after all, doing hardcore embedded
    programming for clients is what we do for a living here at EQATEC.</p>
    
    <p>Best regards,<br />the EQATEC tools team</p>

	
	</body>
</html>
